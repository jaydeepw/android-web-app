<!DOCTYPE HTML>
<html>
<head>
<title></title>

    <!--Old Code 1.0 alpha 1 version-->
<!--	<link rel="stylesheet" href="css/jquery.mobile-1.0a4.1.min.css" />	
	<script type="text/javascript" src="js/phonegap.js"></script>
	<script type="text/javascript" src="js/jquery-1.5.1.min.js"></script>
	<script type="text/javascript" src="js/jquery.mobile-1.0a4.1.min.js"></script>-->
    
    
    <!--New Code 1.0 beta 1 version-->
<!--	<link rel="stylesheet" href="css/jquery.mobile-1.0b1.min.css"/>
	<script type="text/javascript" src="js/phonegap.js"></script>
	<script type="text/javascript" src="js/jquery-1.6.1.min.js"></script>
	<script type="text/javascript" src="js/jquery.mobile-1.0b2.min.js"></script>-->

	<link rel="stylesheet" href="../css/code.css"/>    
    
    <!--New Code 1.0 beta 2 version-->    
	<link rel="stylesheet" href="../css/jquery.mobile-1.0b2.min.css"/>
	<script type="text/javascript" src="../js/jquery-1.6.2.min.js"></script>
	<script type="text/javascript" src="../js/jquery.mobile-1.0b2.min.js"></script>


</head>
<body>
     <div data-role="page" id="home"> 
 		 <div data-role="header">                            <!-- This div with data-role is the header, shown in the black -->
   		   <h1>Performance Best Practices</h1>
           <a data-ajax="false" data-rel="back">back</a>
		   <a data-ajax="false" href="../index.html" data-icon="home" data-iconpos="right">Home</a>
 		 </div> 
         
         <div data-role="content">                           <!-- This div is the body of the page -->
         	<p>
            
            <h3>Improving startup performance</h3>
					Extensions are loaded and run whenever a new browser window opens. That means every time a window opens, your extension can have an impact on how long it takes the user to see the content they're trying to view. There are several things you can do to reduce the amount of time your extension delays the appearance of the user's desired content.
                 <div data-role="collapsible-set" data-theme="b">                                 
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Load only what you need, when you need it</h3>
                              <p>
                              <strong>Load only what you need, when you need it</strong><br/>
                                Don't load things during startup that are only needed if the user clicks a button, or if a given preference is enabled when it's not. If your extension has features that only work when the user has logged into a service, don't load the resources for those features until the user actually logs in.
                              </p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Use JavaScript code modules</h3>
                              <p>
                              <strong>Use JavaScript code modules</strong><br/>
								You can create your own JavaScript code modules incorporating sets of features that are only needed under specific circumstances. This makes it easy to load chunks of your extension on the fly as needed, instead of loading everything all at once.<br/>This has an advantage over XPCOM modules, which are always loaded when your extension starts up.<br/>Of course, for extremely simple extensions it may not make sense to modularize your code.JavaScript modules are just like any other JavaScript, with the exception that they are singletons and Firefox can cache the compiled code for faster use the next time the browser is started. Any time your add-on loads JavaScript from a &lt;script&gt; element or with mozIJSSubScriptLoader , you should consider using a JavaScript Module. For more on how JavaScript modules work, see the Using JavaScript Code Modules page.
                              </p>                  
                         </div>       
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Defer everything that you can</h3>
                              <p>
                              <strong>Defer everything that you can</strong><br/>
                                Most extensions have a load event listener in the main overlay that runs their startup functions. Do as little as possible here. The browser window is blocked while your add-on's load handler runs, so the more it does, the slower Firefox will appear to the user.<br/>If there is anything that can be done even a fraction of a second later, you can use an nsITimer  or the window.setTimeout() method to schedule that work for later.  Even a short delay can have a big impact.</p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Avoid Writing Slow CSS</h3>
                              <p>
                              <strong>Avoid Writing Slow CSS</strong><br/>
                                <ul>
                                   <li>Read the "writing efficient CSS" guide.</li>
                                   <li>Remember that any selector in your rule which might match many different nodes is a source of inefficiency during either selector matching or dynamic update processing. This is especially bad for the latter if the selector can dynamically start or stop matching. Avoid unqualified ":hover" like the plague.</li>
                                </ul>
                              </p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Avoid DOM mutation event listeners</h3>
                              <p>
                              <strong>Avoid DOM mutation event listeners</strong><br/>
                                Adding DOM mutation listeners to a document disables most DOM modification optimizations and profoundly degrades the performance of further DOM modifications to that document. Moreover, removing the listeners does not reverse the damage. For the reason, the following events should be avoided wherever possible: DOMAttrModified, DOMAttributeNameChanged, DOMCharacterDataModified, DOMElementNameChanged, DOMNodeInserted, DOMNodeInsertedIntoDocument, DOMNodeRemoved, DOMNodeRemovedFromDocument, DOMSubtreeModified
                              </p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Lazily load services</h3>
                              <p>
                              <strong>Lazily load services</strong><br>
                                The XPCOMUtils JavaScript module provides two methods for lazily loading things:<br/>
								<ul>
                                   <li>defineLazyGetter() defines a function on a specified object that acts as a getter which will be created the first time it's used. See examples.</li>
                                   <li>defineLazyServiceGetter() defines a function on a specified object which acts as a getter for a service. The service isn't obtained until the first time it's used. Look through the source for examples.</li>
                                </ul>
                                  As of Firefox 4.0, many common services are already cached for you in Services.jsm.
                              </p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Reduce file I/O</h3>
                              <p>
                              <strong>Reduce file I/O</strong><br>
								TODO: Give examples below, link to code, bugs, docs.<br/>
								<ul>
                                   <li>If you're targeting Firefox 3.6 and earlier, or if you're specifying em:unpack then use chrome JARs!</li>
                                   <li>Combine pref files</li>
                                   <li>Combine CSS</li>
                                   <li>Combine interfaces into a single .idl to reduce xpt files</li>
                                   <li>Combine toolbar icons in a single file.</li>
                                </ul>
                                  As of Firefox 4.0, many common services are already cached for you in Services.jsm.
                              </p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Use the right compression level for JAR and XPI files</h3>
                              <p>
                              <strong>Use the right compression level for JAR and XPI files</strong><br>
								Reading data from compressed archives costs time. The higher the compression level of the archive, the higher also the performance cost of reading the data from it. So any JAR files in your extension should always be packed with compression level 0 (no compression) for better performance. It may seem counter-intuitive, but doing this will increase the JAR file size and actually decrease the XPI file size as it allows for compression between files inside the JAR to be done when compressing the XPI (essentially a poor-man's solid archive effect).<br/> <br/>If your extension doesn't specify em:unpack then its XPI file will not be unpacked in Firefox 4 and used directly instead. This makes choosing a low compression level preferable; we recommend using compression level 1. It will increase the download size only a small amount, even compared to maximum compression.<br/>
                              </p>                  
                         </div>     
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Use asynchronous I/O</h3>
                              <p>
                              <strong>Use asynchronous I/O</strong><br>
								This cannot be stressed enough: never do synchronous I/O on the GUI thread.
								<ul>
                                   <li>Never use synchronous XMLHttpRequests (XHR). Use asynchronous requests instead and show a throbber image or message in case you need the user to wait.</li>
                                   <li>NetUtils.jsm provides helpers for asynchronous reading and copying of files.</li>
                                   <li>Never access a SQLite database synchronously. Use the asynchronous API instead.</li>
                                </ul>
                              </p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Unnecessary onreadystatechange in XHR</h3>
                              <p>
                              <strong>Unnecessary onreadystatechange in XHR</strong><br>
								addEventListener(load/error) and/or xhr.onload/.onerror are usually sufficient for most uses and will only be called once, contrary to onreadystatechange. When using XHR in websites people tend to use onreadystatechange (for compatiblity reasons). Often it is enough to just load the resource or handle errors. load/error event listener are far less often called than onreadystatechange, i.e. only once, and you don't need to check readyState or figure out if it is an error or not. Only use onreadystatechange if you want to process the response while it is still arriving.
                              </p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Populate menus as needed</h3>
                              <p>
                              <strong>Populate menus as needed</strong><br>
									Populate "context" menus (page, tabs, tools) as needed and keep computation to a minimum (UI responsiveness). There is no need to populate the context menu every time something changes. It is enough to populate it once the user actually needs it. Add a listener to the "popupshowing" event and compute there.
                              </p>                  
                         </div>                         
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Avoid mouse movement events</h3>
                              <p>
                              <strong>Avoid mouse movement events</strong><br>
								Avoid mouse movement events (enter/over/exit) or at least keep computation to a minimum. Mouse movement events, especially the mouseover event, usually happen at high frequency. Best would be to only store the new information and compute "stuff" once the user actually requests it (e.g. in a popupshowing event). Also don't forget to remove the event listeners when no longer needed (see above).
                              </p>                  
                         </div>                         
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Avoid polling</h3>
                              <p>
                              <strong>Avoid polling</strong><br>
								Use nsIObserverService functionality instead. Everybody is free to post "custom" notifications via nsIObserverService , but few extensions actually use this. However, a lot of other services also provide observer functionality, such as nsIPrefBranch2.
                              </p>                  
                         </div>                         
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>aPNG/aGIF inappropriate in a lot of cases</h3>
                              <p>
                              <strong>aPNG/aGIF inappropriate in a lot of cases</strong><br>
								Animations require a lot of time to set up, as a lot of images are decoded (the frames). Animated images may have their cached representations evicted quite often, causing the frames of your animated images to be reloaded lots of times, not just once. nsITree / tree seems to be extra special in this regard, as it doesn't seem to cache animations at all under certain circumstances.
                              </p>                  
                         </div>                         
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>base64/md5/sha1 implementations</h3>
                              <p>
                              <strong>base64/md5/sha1 implementations</strong><br>
								Do not ship your own base64/md5/sha1 implementations. Regarding base64 there are the built-in atob/btoa functions that do the job just well and are available in overlay script as well as in in JavaScript modules and components. Hashes can be computed using nsICryptoHash , which accepts either a string or an nsIInputStream .
                              </p>                  
                         </div>                         
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Image sprites</h3>
                              <p>
                              <strong>Image sprites</strong><br>
								You may combine multiple images into one (sprites). See -moz-image-region. Most XUL widgets that are used to display some image (incl. button and toolbarbutton) allow to use list-style-image. Avoid the imagesrc/src attributes to define images where possible.
                              </p>                  
                         </div>
                         <div data-role="collapsible" data-collapsed="true" data-theme="b">
                           <h3>Consider using Chrome Workers</h3>
                              <p>
                              <strong>Consider using Chrome Workers</strong><br>
								You can use a ChromeWorker to execute long running tasks or do data processing.
                              </p>                  
                         </div>
                 </div>                                      
            </p>
          </div>
        <div data-role="footer" data-position="fixed">
            <h4>The4thDimension.net</h4> 
        </div>          
     </div> 
 
</body>
</html>

<!-- 

Reference
http://en.wikipedia.org/wiki/Mozilla_Firefox#Market_adoption

 -->